!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASSERT_EQ	testharness.h	103;"	d
ASSERT_GE	testharness.h	105;"	d
ASSERT_GT	testharness.h	106;"	d
ASSERT_LE	testharness.h	107;"	d
ASSERT_LT	testharness.h	108;"	d
ASSERT_NE	testharness.h	104;"	d
ASSERT_OK	testharness.h	102;"	d
ASSERT_TRUE	testharness.h	101;"	d
Any	t2.cpp	/^  Any(){$/;"	f	class:Any
Any	t2.cpp	/^class Any{$/;"	c	file:
BINARY_OP	testharness.h	73;"	d
BINARY_OP	testharness.h	89;"	d
Base	t4.cpp	/^    Base(){$/;"	f	class:Base
Base	t4.cpp	/^class Base{$/;"	c	file:
BaseResource	dynlib.h	/^class BaseResource{$/;"	c
C	t_c11.cpp	/^class C{$/;"	c	file:
CFLAGS	Makefile	/^CFLAGS = -std=c++11 -g -O3 -fPIC -I$(THIRD_DIR)\/leveldb\/include -I..\/share\\$/;"	m
CONTROLLEN	spawn.cpp	16;"	d	file:
COUT	t4.cpp	9;"	d	file:
COUT	t_c11.cpp	23;"	d	file:
CPPFLAGS	Makefile	/^CPPFLAGS = $(CFLAGS)$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = $(CFLAGS)$/;"	m
Children	t2.cpp	/^class Children:public Parent{$/;"	c	file:
DYNLIB_H	dynlib.h	2;"	d
GrandParent	t2.cpp	/^class GrandParent{$/;"	c	file:
Is	testharness.h	/^  Tester& Is(bool b, const char* msg) {$/;"	f	class:test::Tester
IsOk	testharness.h	/^  Tester& IsOk(const int& s) {$/;"	f	class:test::Tester
LDFLAGS	Makefile	/^LDFLAGS := -rdynamic $(LIB) $/;"	m
LIB	Makefile	/^LIB = -L$(SHARE_DIR) -lmisc -lm \\$/;"	m
MISC	misc_ut.cpp	/^class MISC { };$/;"	c	file:
NS_dynlib	dynlib.cpp	/^namespace NS_dynlib{$/;"	n	namespace:ns1	file:
NS_dynlib	dynlib.cpp	16;"	d	file:
Now	t2.cpp	/^time_t Now(){$/;"	f
Obj	t_rapidjson.cpp	/^  Obj(){$/;"	f	class:Obj
Obj	t_rapidjson.cpp	/^class Obj{$/;"	c	file:
Parent	t2.cpp	/^class Parent:public GrandParent{$/;"	c	file:
RandomSeed	testharness.cc	/^int RandomSeed() {$/;"	f	namespace:test
Ref	t4.cpp	/^void Ref(int id){$/;"	f
RegisterTest	testharness.cc	/^bool RegisterTest(const char* base, const char* name, void (*func)()) {$/;"	f	namespace:test
Resource	dynlib.cpp	/^    Resource(){$/;"	f	class:ns1::NS_dynlib::Resource
Resource	dynlib.cpp	/^  Resource(){$/;"	f	class:Resource
Resource	dynlib.cpp	/^  class Resource : public BaseResource{$/;"	c	namespace:ns1::NS_dynlib	file:
Resource	dynlib.cpp	/^class Resource : public BaseResource{$/;"	c	file:
Resource	dynlib1.cpp	/^  Resource(){$/;"	f	class:Resource
Resource	dynlib1.cpp	/^class Resource : public BaseResource{$/;"	c	file:
RunAllTests	testharness.cc	/^int RunAllTests() {$/;"	f	namespace:test
SERVER_PORT	spawn.cpp	14;"	d	file:
STORAGE_LEVELDB_UTIL_TESTHARNESS_H_	testharness.h	6;"	d
Serialize	t_rapidjson.cpp	/^    void Serialize(Writer& writer) const {$/;"	f	class:Obj
SetItem	t_c11.cpp	/^struct SetItem{$/;"	s	file:
StaticMember	dynlib.cpp	/^    StaticMember(){}$/;"	f	class:StaticMember
StaticMember	dynlib.cpp	/^class StaticMember{$/;"	c	file:
StaticMember	dynlib1.cpp	/^    StaticMember(){}$/;"	f	class:StaticMember
StaticMember	dynlib1.cpp	/^class StaticMember{$/;"	c	file:
StaticVar	dynlib.cpp	/^  StaticVar(){$/;"	f	struct:StaticVar
StaticVar	dynlib.cpp	/^struct StaticVar{$/;"	s	file:
StaticVar	dynlib1.cpp	/^  StaticVar(){$/;"	f	struct:StaticVar
StaticVar	dynlib1.cpp	/^struct StaticVar{$/;"	s	file:
Sub	t4.cpp	/^    Sub(int id){$/;"	f	class:Sub
Sub	t4.cpp	/^class Sub:public Base{$/;"	c	file:
TCONCAT	testharness.h	110;"	d
TCONCAT1	testharness.h	111;"	d
TEST	misc_ut.cpp	/^TEST(MISC, time){$/;"	f
TEST	t.cpp	14;"	d	file:
TEST	t_rapidjson.cpp	13;"	d	file:
TEST	testharness.h	113;"	d
TOP_DIR	Makefile	/^TOP_DIR := ..$/;"	m
Test	dynlib.cpp	/^ Test(){$/;"	f	class:Test
Test	dynlib.cpp	/^class Test{$/;"	c	file:
Test	dynlib2.cpp	/^ Test(){$/;"	f	class:Test
Test	dynlib2.cpp	/^class Test{$/;"	c	file:
Test	testharness.cc	/^struct Test {$/;"	s	namespace:test::__anon1	file:
TestCopy	t_c11.cpp	/^struct TestCopy{$/;"	s	file:
Tester	testharness.h	/^  Tester(const char* f, int l)$/;"	f	class:test::Tester
Tester	testharness.h	/^class Tester {$/;"	c	namespace:test
aaa	dynlib.cpp	/^void aaa(){$/;"	f
aaa	dynlib1.cpp	/^void aaa(){$/;"	f
abc	t1.cpp	/^  const static string abc;$/;"	m	class:cls	file:
abc	t1.cpp	/^const string cls::abc = "123";$/;"	m	class:cls	file:
async_run	t_c11.cpp	/^int async_run(int i){$/;"	f
atomic1	t_c11.cpp	/^void atomic1(uint64_t cnt){$/;"	f
atomic1_load	t_c11.cpp	/^void atomic1_load(uint64_t cnt){$/;"	f
atomic1_lock	t_c11.cpp	/^void atomic1_lock(uint64_t cnt){$/;"	f
atomic2	t_c11.cpp	/^void atomic2(uint64_t cnt){$/;"	f
atomic2_load	t_c11.cpp	/^void atomic2_load(uint64_t cnt){$/;"	f
atomic3	t_c11.cpp	/^void atomic3(uint64_t cnt){$/;"	f
base	t_ev.cpp	/^struct event_base* base; $/;"	v	typeref:struct:event_base
base	testharness.cc	/^  const char* base;$/;"	m	struct:test::__anon1::Test	file:
bases	t4.cpp	/^static shared_ptr<Base> bases[2];$/;"	v	file:
clone	dynlib.cpp	/^    BaseResource* clone(){$/;"	f	class:ns1::NS_dynlib::Resource
clone	dynlib.cpp	/^  BaseResource* clone(){$/;"	f	class:Resource
clone	dynlib1.cpp	/^  BaseResource* clone(){$/;"	f	class:Resource
cls	t1.cpp	/^class cls{$/;"	c	file:
created	t_c11.cpp	/^  time_t created;$/;"	m	struct:SetItem	file:
d	dynlib.cpp	/^    vector<int> d;$/;"	m	class:ns1::NS_dynlib::Resource	file:
d	dynlib.cpp	/^  vector<int> d;$/;"	m	class:Resource	file:
data	dynlib.cpp	/^    string data;$/;"	m	class:ns1::NS_dynlib::Resource	file:
data	dynlib.cpp	/^  string data;$/;"	m	class:Resource	file:
data	t_c11.cpp	/^  string data;$/;"	m	struct:SetItem	file:
diff	t1.cpp	/^void diff(int loopCnt, int cnt){$/;"	f
dynlib1_func	dynlib1.cpp	/^int dynlib1_func(){$/;"	f
dynlib1_func1	dynlib1.cpp	/^int dynlib1_func1(){$/;"	f
dynlib_func	dynlib.cpp	/^int dynlib_func(){$/;"	f
dynlib_func	dynlib2.cpp	/^int dynlib_func(){$/;"	f
dynlib_func1	dynlib.cpp	/^int dynlib_func1(){$/;"	f
dynlib_func1	dynlib2.cpp	/^int dynlib_func1(){$/;"	f
dynlib_func2	dynlib.cpp	/^int dynlib_func2(){$/;"	f
dynlib_func2	dynlib2.cpp	/^int dynlib_func2(){$/;"	f
f1	t_c11.cpp	/^string f1(){$/;"	f
fname_	testharness.h	/^  const char* fname_;$/;"	m	class:test::Tester
func	dynlib_main.cpp	/^void func(){$/;"	f
func	t1.cpp	/^void func(int cnt){$/;"	f
func	t2.cpp	/^  int func(){$/;"	f	class:Children
func	t2.cpp	/^  int func(){$/;"	f	class:Parent
func	t2.cpp	/^  virtual int func(){$/;"	f	class:GrandParent
func	testharness.cc	/^  void (*func)();$/;"	m	struct:test::__anon1::Test	file:
func1	t2.cpp	/^  int func1(){$/;"	f	class:Children
func1	t2.cpp	/^  int func1(){$/;"	f	class:Parent
func1	t2.cpp	/^  virtual int func1(){$/;"	f	class:GrandParent
func2	t2.cpp	/^  int func2(){$/;"	f	class:Children
func2	t2.cpp	/^  virtual int func2(){$/;"	f	class:Parent
func3	t2.cpp	/^  int func3(){$/;"	f	class:Parent
func3	t2.cpp	/^  virtual int func3(){$/;"	f	class:Children
funcRes_t	dynlib.h	/^typedef BaseResource *(*funcRes_t)();$/;"	t
func_t	dynlib.h	/^typedef int (*func_t)();$/;"	t
fut	t_c11.cpp	/^shared_future<bool> fut;$/;"	v
fut_wait	t_c11.cpp	/^void fut_wait(){$/;"	f
g_sptrs	t_c11.cpp	/^shared_ptr<int> g_sptrs[100];$/;"	v
get_object_id	t2.cpp	/^string get_object_id(string &str){$/;"	f
i	t_rapidjson.cpp	/^  int i;$/;"	m	class:Obj	file:
id_	t4.cpp	/^    int id_;$/;"	m	class:Base	file:
j	t_rapidjson.cpp	/^  int j;$/;"	m	class:Obj	file:
line_	testharness.h	/^  int line_;$/;"	m	class:test::Tester
load	dynlib.cpp	/^    void load(){$/;"	f	class:ns1::NS_dynlib::Resource
load	dynlib.cpp	/^  void load(){$/;"	f	class:Resource
load	dynlib.h	/^  virtual void load(){$/;"	f	class:BaseResource
load	dynlib1.cpp	/^  void load(){$/;"	f	class:Resource
main	dynlib_main.cpp	/^int main(int, char**argv){$/;"	f
main	misc_ut.cpp	/^int main(int argc, char** argv){$/;"	f
main	spawn.cpp	/^int main (int argc, char *argv[])$/;"	f
main	t.cpp	/^int main(int argc, char**argv){$/;"	f
main	t1.cpp	/^int main(int argc, char**argv){$/;"	f
main	t2.cpp	/^int main(){$/;"	f
main	t4.cpp	/^int main () {$/;"	f
main	t_c11.cpp	/^int main () {$/;"	f
main	t_ev.cpp	/^int main() { $/;"	f
main	t_json.cpp	/^int main(int argc, char**argv){$/;"	f
main	t_lvdb.cpp	/^int main(int argc, char**argv){$/;"	f
main	t_rapidjson.cpp	/^int main(int argc, char**argv){$/;"	f
main_func	dynlib_main.cpp	/^int main_func(){$/;"	f
mtx1	t_c11.cpp	/^mutex mtx1;$/;"	v
name	dynlib.h	/^  std::string name;$/;"	m	class:BaseResource
name	testharness.cc	/^  const char* name;$/;"	m	struct:test::__anon1::Test	file:
ns1	dynlib.cpp	/^namespace ns1{$/;"	n	file:
ok_	testharness.h	/^  bool ok_;$/;"	m	class:test::Tester
onAccept	t_ev.cpp	/^void onAccept(int iSvrFd, short iEvent, void *arg) { $/;"	f
onRead	t_ev.cpp	/^void onRead(int iCliFd, short iEvent, void *arg) { $/;"	f
operator <	t_c11.cpp	/^  bool operator < (const SetItem &rhs) const{$/;"	f	struct:SetItem
operator <<	testharness.h	/^  Tester& operator<<(const V& value) {$/;"	f	class:test::Tester
operator =	t_c11.cpp	/^  TestCopy & operator=( TestCopy &input){$/;"	f	struct:TestCopy
p	t4.cpp	/^    void *p;$/;"	m	class:Base	file:
prom	t_c11.cpp	/^promise<bool> prom;$/;"	v
recv_fd	spawn.cpp	/^int recv_fd( int sockfd ) {$/;"	f
run	t4.cpp	/^    virtual void run(){$/;"	f	class:Base
run	t4.cpp	/^    virtual void run(){$/;"	f	class:Sub
same1_func	dynlib.cpp	/^void same1_func(){$/;"	f
same1_func	dynlib2.cpp	/^void same1_func(){$/;"	f
same_func	dynlib.cpp	/^extern BaseResource* same_func(){$/;"	f
same_func	dynlib1.cpp	/^extern BaseResource* same_func(){$/;"	f
same_func	dynlib2.cpp	/^extern BaseResource* same_func(){$/;"	f
send_fd	spawn.cpp	/^int send_fd (int sockfd, int fd) {$/;"	f
sptr_perf_thread	t_c11.cpp	/^void sptr_perf_thread(int p){$/;"	f
sptr_thread	t_c11.cpp	/^void sptr_thread(){$/;"	f
ss_	testharness.h	/^  std::stringstream ss_;$/;"	m	class:test::Tester
staticVar	dynlib.cpp	/^    static StaticVar staticVar;$/;"	m	class:StaticMember	file:
staticVar	dynlib.cpp	/^StaticVar StaticMember::staticVar;$/;"	m	class:StaticMember	file:
staticVar	dynlib1.cpp	/^    static StaticVar staticVar;$/;"	m	class:StaticMember	file:
staticVar	dynlib1.cpp	/^StaticVar StaticMember::staticVar;$/;"	m	class:StaticMember	file:
t_any	t2.cpp	/^void t_any(){$/;"	f
t_copy	t_c11.cpp	/^void t_copy(){$/;"	f
t_future	t_c11.cpp	/^void t_future(){$/;"	f
t_hash	t_c11.cpp	/^void t_hash(){$/;"	f
t_it	t1.cpp	/^void t_it(){$/;"	f
t_localtime_r	t1.cpp	/^void t_localtime_r(){$/;"	f
t_log10f	t2.cpp	/^void t_log10f(){$/;"	f
t_map	t2.cpp	/^void t_map(){$/;"	f
t_memmove	t2.cpp	/^void t_memmove(){$/;"	f
t_mktime	t2.cpp	/^void t_mktime(){$/;"	f
t_openmp	t1.cpp	/^void t_openmp(){$/;"	f
t_readlink	t1.cpp	/^void t_readlink(){$/;"	f
t_set	t1.cpp	/^void t_set(){$/;"	f
t_set_del	t_c11.cpp	/^void t_set_del(){$/;"	f
t_shared_ptr	t_c11.cpp	/^void t_shared_ptr(){$/;"	f
t_strftime	t1.cpp	/^void t_strftime(){$/;"	f
t_string	t2.cpp	/^void t_string(){$/;"	f
t_vec	t2.cpp	/^void t_vec(){$/;"	f
t_vec	t_c11.cpp	/^void t_vec(){$/;"	f
t_virtualFunc	t2.cpp	/^void t_virtualFunc(){$/;"	f
target	Makefile	/^target = t t1 t2 t_c11 t4 t_ev spawn dynlib_main dynlib.so dynlib1.so.1 t_rapidjson$/;"	m
test	testharness.cc	/^namespace test {$/;"	n	file:
test	testharness.h	/^namespace test {$/;"	n
test_any	t2.cpp	/^Any test_any(){$/;"	f
test_async	t_c11.cpp	/^void test_async(){$/;"	f
test_atomic	t_c11.cpp	/^void test_atomic(){$/;"	f
test_autofile	t_c11.cpp	/^void test_autofile(){$/;"	f
test_gdb_map	t_c11.cpp	/^void test_gdb_map(){$/;"	f
test_heap	t_c11.cpp	/^void test_heap(){$/;"	f
test_map	t_c11.cpp	/^void test_map(){$/;"	f
test_map_perf	t_c11.cpp	/^void test_map_perf(){$/;"	f
test_map_perf1	t_c11.cpp	/^void test_map_perf1(){$/;"	f
test_priority_queue	t_c11.cpp	/^void test_priority_queue(){$/;"	f
test_set	t_c11.cpp	/^void test_set(){$/;"	f
test_shared_ptr	t_c11.cpp	/^void test_shared_ptr(){$/;"	f
test_vec_perf1	t_c11.cpp	/^void test_vec_perf1(){$/;"	f
tests	testharness.cc	/^std::vector<Test>* tests;$/;"	m	namespace:test::__anon1	file:
total1	t_c11.cpp	/^uint64_t total1;$/;"	v
total2	t_c11.cpp	/^atomic<uint64_t> total2;$/;"	v
total3	t_c11.cpp	/^atomic_long total3;$/;"	v
ut_ctype	t.cpp	/^void ut_ctype(){$/;"	f
ut_enum	t.cpp	/^void ut_enum() {$/;"	f
ut_int	t.cpp	/^void ut_int(){$/;"	f
ut_map	t.cpp	/^void ut_map(){$/;"	f
ut_mul	t.cpp	/^void ut_mul(){$/;"	f
ut_obj	t_rapidjson.cpp	/^void ut_obj(){$/;"	f
ut_stream	t.cpp	/^void ut_stream(){$/;"	f
ut_string	t.cpp	/^void ut_string(){$/;"	f
ut_strtoul	t.cpp	/^void ut_strtoul(){$/;"	f
ut_time	t.cpp	/^void ut_time(){$/;"	f
ut_transfrom	t.cpp	/^void ut_transfrom(){$/;"	f
v1	t_c11.cpp	/^  atomic<int> v1;$/;"	m	struct:TestCopy	file:
~Any	t2.cpp	/^  ~Any(){$/;"	f	class:Any
~Base	t4.cpp	/^    ~Base(){$/;"	f	class:Base
~C	t_c11.cpp	/^    ~C(){$/;"	f	class:C
~StaticMember	dynlib.cpp	/^    ~StaticMember(){}$/;"	f	class:StaticMember
~StaticMember	dynlib1.cpp	/^    ~StaticMember(){}$/;"	f	class:StaticMember
~StaticVar	dynlib.cpp	/^  ~StaticVar(){$/;"	f	struct:StaticVar
~StaticVar	dynlib1.cpp	/^  ~StaticVar(){$/;"	f	struct:StaticVar
~Sub	t4.cpp	/^    ~Sub(){$/;"	f	class:Sub
~Tester	testharness.h	/^  ~Tester() {$/;"	f	class:test::Tester
